# 2 补充

# 1 接口的层次结构
![1619425727769-70c3cd2c-61ab-41fc-aa49-c94eef78d099.jpeg](4%20Java/集合/img/wHM-CWUM1LcDwnXH/1619425727769-70c3cd2c-61ab-41fc-aa49-c94eef78d099-457007.jpeg)



# 2 泛型
泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？

顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。

泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。

**泛型**

+ <font style="color:rgb(0, 0, 0);">本质就是“数据类型的参数化”。</font>
+ <font style="color:rgb(0, 0, 0);">告诉编译器，在调用泛型时必须传入实际类型。</font>

**自定义泛型**

+ <font style="color:rgb(0, 0, 0);">可以在类的声明处增加泛型列表，如：</font><font style="color:rgb(0, 0, 0);">。</font>
+ <font style="color:rgb(0, 0, 0);">此处，字符可以是任何标识符，一般采用这3个字母。</font>

**【示例】泛型类的声明**

```java
class MyCollection<E> {// E:表示泛型;
    Object[] objs = new Object[5];
 
    public E get(int index) {// E:表示泛型;
        return (E) objs[index];
    }
    public void set(E e, int index) {// E:表示泛型;
        objs[index] = e;
    }
}           
```

个人理解：泛型类似形式参数，表示“未知的某个数据类型”，需要我们传入这个“数据类型”

**【示例】泛型类的应用**

```java
public class TestGenerics{
    public static void main(String[] args){
        MyCollection<String> mc = new MyCollection<String>();
        mc.set("aaa", 0);
        mc.set("bbb", 1); 
        String str = mc.get(1); //加了泛型，直接返回String类型，不用强制转换;
        System.out.println(str);
    }
    
}
输出结果：
    aaa
    bbb
```



# 3 Collection 接口
Collection表示一组对象。Collection接口的两个子接口是List、Set接口。

Set接口：.

没有顺序，不可重复

List接口：

有顺序，可以重复

ArrayList：底层的数组实现

LinkedLIst：底层的链表实现

![1619425865194-4225e142-3a2d-4596-9772-c38c49d4dc74.jpeg](4%20Java/集合/img/wHM-CWUM1LcDwnXH/1619425865194-4225e142-3a2d-4596-9772-c38c49d4dc74-632520.jpeg)

**【示例】容器的使用**

```java
public class TestArrayList2 {
    public static void main(String[] args) {
        Collection<String> c = new ArrayList<>();   //创建ArrayList对象
        System.out.println(c.size()); 
        c.add("aa");    //添加字符串
        c.add("bb");
        System.out.println(c);
        System.out.println(c.size());
        c.remove("aa");     //删除字符串
        System.out.println(c);
    }
}
```

注意：    

首先创建两个对象"aa"、"bb"，在容器c中存放的是两个对象的地址

remove()移除的是c中对象的地址，而对象本身还在。



# 4 List、Set
List是有序、可重复的容器。

+ <font style="color:rgb(0, 0, 0);">有序：List中每个元素都有索引标记。可以根据元素的索引标记(在List中的位置)访问元素，从而精确控制这些元素。</font>
+ <font style="color:rgb(0, 0, 0);">可重复：List允许加入重复的元素。更确切地讲，List通常允许满足 e1.equals(e2) 的元素重复加入容器。</font>

![1619425926188-b890e386-416f-4e72-837e-ffb74a877117.jpeg](4%20Java/集合/img/wHM-CWUM1LcDwnXH/1619425926188-b890e386-416f-4e72-837e-ffb74a877117-015290.jpeg)

List接口常用的实现类有3个：ArrayList、LinkedList和Vector

Set容器特点：无序、不可重复。

无序指Set中的元素没有索引，我们只能遍历查找;不可重复指不允许加入重复的元素。更确切地讲，新元素如果和Set中某个元素通过equals()方法对比为true，则不能加入;甚至，Set中也只能放入一个null元素，不能多个。

      Set常用的实现类有：HashSet、TreeSet等，我们一般使用HashSet。

 Set接口继承自Collection，Set接口中没有新增方法，方法和Collection保持完全一致。List接口中的方法在set中同样适用。



# 5 存储表格数据
有如下表格：

| <font style="color:rgb(0, 0, 0);">ID</font> | <font style="color:rgb(0, 0, 0);">姓名</font> | <font style="color:rgb(0, 0, 0);">薪水</font> | <font style="color:rgb(0, 0, 0);">入职日期</font> |
| --- | --- | --- | --- |
| <font style="color:rgb(0, 0, 0);">1001</font> | <font style="color:rgb(0, 0, 0);">张三</font> | <font style="color:rgb(0, 0, 0);">20000</font> | <font style="color:rgb(0, 0, 0);">2018.5.5</font> |
| <font style="color:rgb(0, 0, 0);">1002</font> | <font style="color:rgb(0, 0, 0);">李四</font> | <font style="color:rgb(0, 0, 0);">30000</font> | <font style="color:rgb(0, 0, 0);">2005.4.4</font> |
| <font style="color:rgb(0, 0, 0);">1003</font> | <font style="color:rgb(0, 0, 0);">王五</font> | <font style="color:rgb(0, 0, 0);">3000</font> | <font style="color:rgb(0, 0, 0);">2020.5.4</font> |


1、通过每一行数据使用一个Map

2、整个表格使用一个List

（ORM思想：对象关系映射）

**【示例】存储表格数据**

```java
package com.ZZF.Test;
import java.util.*;

/**
 * 测试表格数据的存储
 * ORM思想的简单实验：map表示一行数据，多行数据存入多个map中，将多个map存入list中
 */
public class TestStoreData {
    public static void main(String[] args) {

        Map<String, Object> row1 = new HashMap<>();
        row1.put("id", 1001);
        row1.put("name", "张三");
        row1.put("薪水", 20000);
        row1.put("入职时间", "2018.5.5");

        Map<String, Object> row2 = new HashMap<>();
        row2.put("id", 1002);
        row2.put("name", "李四");
        row2.put("薪水", 30000);
        row2.put("入职时间", "2005.4.4");

        Map<String, Object> row3 = new HashMap<>();
        row3.put("id", 1003);
        row3.put("name", "王五");
        row3.put("薪水", 3000);
        row3.put("入职时间", "2020.5.4");

        List<Map<String, Object>> table1 = new ArrayList<>();
        table1.add(row1);
        table1.add(row2);
        table1.add(row3);

        for (Map<String, Object> row : table1) {
            Set<String> keyset = row.keySet();
            for (String key : keyset) {
                System.out.print(key + ":" + row.get(key) + "\t");
            }
            System.out.println();
        }
    }
}
```



# 6 Map 常用方法
Map就是用来存储“键(key)-值(value) 对”的。 Map类中存储的“键值对”通过键来标识，所以“键对象”不能重复。

![1619426011383-73572ca5-a117-4f89-bfb7-1f058f4f86dd.jpeg](4%20Java/集合/img/wHM-CWUM1LcDwnXH/1619426011383-73572ca5-a117-4f89-bfb7-1f058f4f86dd-511875.jpeg)

**【示例】Map常用方法**

```java
package com.ZZF.Test;

import java.util.HashMap;
import java.util.Map;

public class TestMap2 {
    public static void main(String[] args) {
        Employee e1 = new Employee(1001, "zzf1", 2000);
        Employee e2 = new Employee(1002, "zzf2", 3000);
        Employee e3 = new Employee(1003, "zzf3", 4000);

        Map<Integer, Employee> map = new HashMap<>();
        map.put(1001, e1);
        map.put(1002, e2);
        map.put(1003, e3);

        Employee employee = map.get(1001);
        System.out.println(employee.getEname());

    }
}

class Employee {
    private int id;
    private String ename;
    private double salary;

    public Employee(int id, String ename, double salary) {
        this.id = id;
        this.ename = ename;
        this.salary = salary;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getEname() {
        return ename;
    }

    public void setEname(String ename) {
        this.ename = ename;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }
}
```



> 更新: 2023-11-18 14:48:13  
> 原文: <https://www.yuque.com/zhangxiaofani4cu/xih3ez/oabsly>