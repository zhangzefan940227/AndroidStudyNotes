## 1 锁分类

- **乐观**锁/**悲观**锁：线程是否需要对资源加锁
- **自旋**锁/**适应性自旋**锁：资源已经被锁定，线程是否阻塞
- **可重入**锁(递归锁)和**不可重入**锁(自旋锁)：在嵌套调用中可以重复获取锁
- **可中断**锁：在线程阻塞时等待超时后中断
- **无锁**、**偏向锁**、 **轻量级锁** 和 **重量级锁**

- 从多个线程并发访问资源，Synchronized 四种状态

- **公平**锁和**非公平**锁：多个线程获取锁的顺序是否根据排队顺序
- **排他**锁和**共享**锁：多个线程能否获取同一把锁

### 1.1 悲观锁/乐观锁

从广义上，Java 按照是否对资源加锁分为**乐观锁**和**悲观锁**，它们并不是一种真实存在的锁，而是一种设计思想，乐观锁和悲观锁对于理解 Java 多线程和数据库来说至关重要。

**悲观锁**

对于同一个数据的并发操作，悲观锁认为自己在使用数据的过程中，一定有其他线程会修改这个数据，所以在获取资源会先加锁。**适用写操作多的场景。**

悲观锁在Java中的使用，就是利用各种锁，synchronized和ReentrantLock 是悲观锁**；**

**乐观锁**

认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。**适用读操作多的场景。**

**CAS算法**（无锁算法）：检查当前引用和预期引用、当前标志和预期标志是否相等。如果都相等，以原子方式进行更新。

通俗的讲，服务器代码预期是A状态，本地修改后变成了B，推送之前检查服务器代码还是不是A，是则push，否则放弃当前操作

### 1.2 自旋锁/适应性自旋锁

尝试获取锁的线程不会立即阻塞，而是采用循环的方式(当循环条件被其他线程改变时才能进入临界区)去尝试获取锁。优点是：减少线程上下文切换的消耗，缺点是：循环会占有、浪费CPU。

![](4%20Java/4.2%20%E8%BF%9B%E9%98%B6/img/1bb69db8a1b4f461d510803151bf837c_MD5.png)

**适应性自旋锁**

- 自旋锁在Java1.6中改为默认开启，并引入了自适应的自旋锁。
- 自适应意味着自旋的次数不在固定，而是由前一次在同一个锁上的自旋时间和锁的拥有者的状态共同决定。

- 如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很可能再次成功的，进而它将会允许线程自旋相对更长的时间。
- 如果对于某个锁，线程很少成功获得过，则会相应减少自旋的时间甚至直接进入阻塞的状态，避免浪费处理器资源。

### 1.3 可重入锁(递归锁)与不可重入锁(自旋锁)

当一个线程获得了当前实例的锁，并进入方法A，这个线程在没有释放这把锁的时候，能否再次进入方法A，或者进入同一把锁的方法B？

**可重入锁（又名递归锁）**

- 是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。
- Java中 synchronized、ReentrantLock、ReentrantReadWriteLock 都是可重入锁。
- 可重入锁的一个优点是可一定程度避免死锁。
- 可重入就意味着：线程可以进入任何一个它已经拥有的锁所同步着的代码中。

**不可重入锁，也叫自旋锁**

- 不可以再次进入方法A，也就是说获得锁进入方法A是此线程在释放锁钱唯一的一次进入方法A。

### 1.4 无锁/偏向锁/轻量级锁/重量级锁

Java 语言专门针对**synchronized**关键字设置了四种状态，它们分别是：**无锁、偏向锁、轻量级锁和重量级锁**

这4种锁的状态是通过对象监视器在对象头中的字段来表明的。

- **无锁**：也就是无状态的时候，对象头开辟 25bit 的空间用来存储对象的 hashcode ，4bit 用于存放分代年龄，1bit 用来存放是否偏向锁的标识位，2bit 用来存放锁标识位为01
- **偏向锁**：是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
- **轻量级锁**：是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
- **重量级锁**：是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。

### 1.5 公平锁/非公平锁

- 公平锁：是指多个线程按照获取锁的顺序，是按照申请锁的顺序。

Synchronized 是非公平锁；因为它不能像 ReentrantLock 那样通过AQS(AbstractQueuedSynchronizer) 来实现线程调度，所以并没有任何办法使其变成公平锁。

- 非公平锁：是指多个线程获取锁的顺序，并不是按照申请锁的顺序；有可能后申请的线程比先申请的线程优先获取锁，也有可能造成优先级反转或者饥饿现象。

ReentrantLock 通过构造函数指定是否为公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。

### 1.6 独享锁(互斥锁)/共享锁（读写锁）

独享锁/共享锁是一种广义的说法，互斥锁/读写锁就是具体的实现

- 独享锁（互斥锁）：是指该锁一次只能被一个线程所持有。

synchronized 和 ReentrantLock 。

- 共享锁（读写锁）：是指该锁可被多个线程所持有。

ReentrantReadWriteLock是读写锁，其读锁是共享锁（读读过程是共享的，保证高效并发读），其写锁是排他锁（读写，写读，写写过程是互斥的）。

### 1.7 分段锁(细粒度锁)

分段锁是一种锁的设计，并不是一种具体的锁；分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一段进行加锁操作。

## 2 ConcurrentHashMap

HashMap存在线程安全问题。解决方案有：改用 HashTable 或者 Collections.synchronizedMap() 方法

但是这两者都有一个问题，就是性能，无论读还是写，他们两个都会给整个集合加锁，导致同一时间的其他操作阻塞。ConcurrentHashMap并非锁住整个方法，而是通过原子操作和局部加锁的方法保证了多线程的线程安全，且尽可能减少了性能损耗。

数据结构和HashMap保持一致。采用CAS + synchronized实现更加细粒度的锁

![](4%20Java/4.2%20%E8%BF%9B%E9%98%B6/img/aa10324abe8b84269fafa4fdd9f9bcfd_MD5.png)